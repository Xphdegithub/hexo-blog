---
title: 运算符
date: 2022-05-31 09:30:03
tags: JavaScript
categories:
 - JavaScript
---
#  运算符

## 操作符和操作数

操作符：运算符，参与运算的符号

操作数：参与运算的数据，也称之为“元”

操作符不一定只有一个符号

```js
// 比如
() // 访问符，用于访问对象的属性
[] // 访问符，用于访问对象的属性
```

操作符出现在不同的位置，可能具有不同的含义

```js
1-2 // 表示减
-1.2 // 表示负号
```

## 表达式

> **表达式 = 操作符 + 操作数**

每个表达式都有一个运算结果，该结果叫做**返回值**，返回值的类型叫做**返回值类型**

**所有的表达式都可以当做数据使用**

```js
1+1 // 这就是个表达式
```

如果是一个声明+赋值的表达式，返回的结果是`undefined`

## 算术运算符

- `+ - * /`【加减乘除】
- `%`【求余】

- `**`求幂

> 1. 在`js`中数字运算是不精确的
>
> 2. 除数为0
>
>    如果被除数是正数，得到的结果为`Infinity`【正无穷】
>
>    如果被除数是负数，得到的结果为`-Infinity`【负无穷】
>
>    如果被除数是0，得到的结果为`NaN`【Not a Number】（非数字）
>
>    `NaN`、`Infinity`和`-Infinity`都是特殊的`Number`类型
>
>    `NaN`虽然是数字，但他和任何数字做任何运算都得到`NaN`
>
>    `isNaN()`：用于判断一个数据是否为`NaN`，返回值为`boolean`
>
>    `isFinite()`：用于判断一个数据是否有限，返回值为`boolean`

- 自增（`++`）和自减（`--`）

  `++`: 将某个**变量**的值自增1

  `--`: 将某个**变量**的值自减1

  > 自增和自减运算符只能作用于变量

   - 位置不同得到的结果也不同

     `x++/--`: 将变量`x`自增/减1，得到的表达式的值为自增/减之前的值

     `++/--x`: 将变量`x`自增/减1，得到的表达式的值为自增/减之后的值

  ```js
  let x = 1;
  console.log(x++); // 1
  console.log(++x); // 2
  ```

### 优先级

`++ --` > `* / % ` > `+ -`

> 正确的运算方式：
>
> 1. 从左到右依次查看
> 2. 如果遇到操作数，将数据的值直接取出（如：let x=1; x + x++ * ++x， 从左到右看，第一个x就直接取出,其值为1，不要管后面的x++、++x）
> 3. 如果遇到相邻的两个运算符，并且左边的运算符优先级大于右边的运算符，则直接运行左边的运算符
> 4. 当遇到小括号时，也应当从左到右看，遵循以上规则，不应该直接先算小括号里的，被惯性思维所迷惑

```js
let x = 1;
let y = x + x++ * ( x = x + x++ * ++x ) + x; // 21
```

此种情况下，若先算小括号里的内容，结果就会算错！（别问我怎么知道的……😂）

### 隐式类型转换

1. 除`+`以外的算术运算符

   将原始类型转换为数字类型（自动完成转换），然后进行运算

   - `boolean`

     - `true` ---> 1

     - `false` ---> 0

   - `string`
     - 如果是一个字符串类型的数字（如："123"），直接变为`number`类型
     - 如果是一个非字符串类型的数字（如："hahaha"），则得到`NaN`
     - 可以识别`Infinity`和`-Infinity`
     - 如果是一个空字符串则转换为0（字符串转换时，会忽略字符串中的空格）

   ```js
   // 只有加号和减号可以直接在数据前面转换，别的符号需要2个以上数据进行运算才会进行转换，否则会报错
   // 其实直接在数据前使用加号和减号表示证号和负号
   console.log(+"Infinity"); // Infinity
   console.log(+Infinity); // Infinity
   console.log(+""); // 0
   console.log(-"123"); // -123
   console.log(+"   123"); // 123
   console.log(+"12321    12312"); // NaN
   ```

   - `null` ---> 0
   - `undefine`---> `NaN`
   - `Object`
     - `Object` ---> `"[object object]"` ---> `NaN`
     - 转换流程：`Object` ---> `String` ---> `Number`

2. 加号运算符

   - 加号一边有字符串，含义变为字符串拼接，会将另一边的其他类型也转换为字符串
     - `number` ---> `"number"`（字符串类型的数字）
     - `boolean` ---> `"boolean"`（字符串类型的布尔）
     - `undefined` ---> `"undefined"`（字符串类型的`undefined`）
     - `Object` ---> `"[object object]"`（能看出来是个字符串吧~）
   - 加号两边都没有字符串，但一边有对象，将对象转换为字符串，然后按照上面的规则进行

> 类型转换并不会改变原本的数据类型，只在运算的时候起作用

## 比较运算符

大小比较：`>	<	>=	<=`

相等比较：`==	!=	===	!==`

**比较运算符的返回值类型：`boolean`**

**算术比较符的优先级大于比较运算符的优先级**

```js
console.log(2 + 3 >= 5); // true
// 先运算 2+3 后比较
```

>- 大小比较
>
>1. 两个字符串比较大小，比较的是字符串的`ASCLL`码
>
>2. 如果一方不是字符串，且两方都是原始类型，他们将转换为数字类型进行比较
>
>  `'1'` ---> 1
>
>  `''` ---> 0
>
>  ..........（与隐式转换的规则相同）
>
>  `NaN`与任何数据（包括它本身）比较都是`false`
>
>  `Infinity`比任何数字都大
>
>  `-Infinity`比任何数字都小
>
>3. 如果其中一方是对象，将对象转换为原始类型后比较
>
>- 相等比较
>
>1. 两端的数据类型相同，直接比较两个数据本身是否相同（两个对象则比较地址）
>
>2. 两端类型不同
>
>  1）`null`和`undefined`之间相等，但是和其他原始类型比较则不相等（如：`null`== 0  为`false`）
>
>  2） 其他原始类型比较时先转换为数字再进行比较
>
>  3） `NaN`与任何数字都不相等（包括它自身）
>
>  4）`Infinity`和`-Infinity`只能和它自身相等
>
>  5） 对象比较时，要先转换为原始类型后再进行比较
>
>  **由于相等（`==`）和不相等（`!=1`）比较,对于不同类型的数据比较存在很多不合理的地方，因此，通常我们不适用这种方式进行比较，而是使用更加合理的严格相等（`===`）和严格不相等（`!==`）来进行比较**
>
>- 严格相等和严格不相等
>
>  `===`: 所比较的两方**数据和数据类型必须相同**才为`true`，否则为`false`
>
>  `!==`: 所比较的两方**数据或类型不同**为`true`，否则为`false`

## 逻辑运算符

- 与（并且）

  符号: `&&`

  书写方式: `表达式1 && 表达式2`

  > 先对表达式1进行`boolean`判断
  >
  > 若为`true`则对表达式2进行判断；
  >
  > 若表达式1未`false`，则直接返回`false`，后面的就不管了
  >
  > **总结一句：与符号返回的是第一个判断为`false`的表达式**（短路规则）

  以下数据均判断为`false`

  1） `null`

  2）`undefined`

  3） `false`

  4） `NaN`

  5） `''`

  6）`0`

- 或

  符号：`||`

  书写方式：`表达式1 || 表达式2`

  >先对表达式1进行`boolean`判断
  >
  >若为`true`则直接返回，后面的就不管了
  >
  >若表达式1为`false`则对表达式2进行判断
  >
  >**总结一句：或符号返回的是第一个判断为`true`的表达式**（和与符号真好相反）

- 非

  符号：`!`

  书写方式：`!数据`

  > 将数据的`boolean`判定结果直接取反，非运算符一定返回`boolean`类型

## 三目运算符

书写方式：`表达式1 ?  表达式2  :  表达式3`

> 对表达式1进行`boolean`判断，若为`true`返回表达式2，若为`false`返回表达式3

## 其他运算符

- `+=   -+   *=   /=  %=  **=`

```js
let x = 2;
x += 1; // 等同于 x = x + 1
x -= 1; // 等同于 x = x - 1
x *= 1; // 等同于 x = x * 1
x *= 1 + 2; // 等同于 x = x * (1 + 2)
x /= 1; // 等同于 x = x / 1;
x %= 1; // 等同于 x = x % 1;
x **= 2; // 等同于 x = x ** 2
```

- `void运算符`

  书写方式 : `void 表达式`或`void(表达式)`

  运行表达式，然后返回`undefined`（额，貌似没啥用……）

- `typeof运算符`

  书写方式 : `typeof 表达式`或`typeof(表达式)`

  返回表达式的类型，是一个字符串

  `typeof`运算符的优先级高于算术运算符，所以建议使用第二种方式，可以避免一些错误

- 逗号运算符

  书写方式 : `表达式1 , 表达式2`

  依次运行两个（个数不固定，有几个运行几个）表达式，返回表达式2（返回最后一个表达式）

  逗号运算符的优先级比赋值符号还低



