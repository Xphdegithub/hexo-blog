---
title: 函数
date: 2022-07-04 18:33:59
tags: JavaScript
categories:
 - JavaScript
---

# 函数

## 创建（定义、声明）函数

``` js
function 函数名() {
    // 函数体
}
```

函数体的代码不会直接运行，必须手动调用函数才能运行其中的代码

## 调用函数

运行函数

```js
函数名();
```

## 函数提升

通过字面量声明的函数，会提升到脚本块的顶部

通过字面量声明的函数，会成为全局对象的属性

## 其他特点

通过`typeof 函数名`，得到的结果是`function`

> 函数内部声明变量
>
> 1. 如果**不使用**`var`声明，和全局变量一致，表示给全局对象添加属性
> 2. 如果**使用**`var`声明，变量提升到所在函数的顶部，函数外部**不可以**直接使用该变量

## 参数

参数表示函数运行的未知条件，需要调用者告知的数据

```js
// 参数的有效返回在函数体中
function 函数名(形参1, 形参2, ...) {
	// 函数体	
};
函数名(实参);
```

如果实参没有传递，则对应的形参为`undefined`

## 返回值

函数运行后，得到的结果，调用函数时，调用表达式的值就是函数的返回值

`return`会直接结束整个函数的运行

`return`后面如果不跟任何数据，返回`undefined`

如果函数中没有书写`return`，则该函数会在末尾自动`return undefined`

## 作用域

作用域表示一个代码区域，也表示一个运行环境

JS中有两种作用域

1. 全局作用域

   直接在脚本中书写的代码

   在全局作用域中声明的变量，会被提升到脚本快的顶部，并且会成为全局对象的属性

2. 函数作用域

   函数中的代码

   在函数作用域中声明的变量，会被提升到函数的顶部，并且不会成为全局对象的属性

   **因此，函数中声明的变量不会导致全局对象的污染，所以，我们应当尽量的把功能封装在函数中**

   但是，当函数成为一个表达式的时候，他既不会提升，也不会污染全局变量。

   将函数变为一个函数表达式的方式之一，将函数用小括号括起来，然而，这样一来，函数无法通过名称调用。

   如果书写一个函数表达式，并且立即调用，该函数称之为立即执行函数，由于大部分情况下，函数表达式的函数名没有实际意义，因此可以忽略函数名

   ```js
   (function() {
       //...
   })();
   (function() {
       //...
   }());
   ```

   ### 作用域中可以使用的变量

   全局作用域只能使用全局作用域中声明的变量（包括函数）

   函数作用域不仅能使用自身作用域中声明的变量（包括函数），还能使用外部环境的变量（包括函数）

   有的时候，某个函数比较复杂，在编写的过程，可能需要另一些函数来辅助完成一些功能，而这些函数仅仅会被该函数使用，不会在其他位置使用，则可以将这些函数声明到该函数的内部

   函数内部声明的变量和外部冲突时，使用内部的

   ## 闭包

   严格来说，闭包（`closure`）是一种现象，即函数内部使用了函数外部的环境中的变量。详细内容会在后面补充，具体链接之后补全。

   先假装这里有个链接……🤣
   
   ## 函数表达式
   
   `JS`中，函数也是一种数据，语法上，函数可以用于任何需要数据的地方
   
   `JS`中，函数时一等公民
   
   函数是引用类型，将其赋值给某个变量时，变量中保存的是函数的地址
   
   ```js
   let func = function() { 
   	// 这是一个函数表达式
   }
   ```
   
   ## this关键字
   
   > `this`无法赋值

1. 在全局作用域中，`this`关键字固定指向全局对象`window`
2. 在函数作用域中，取决于函数是如何被调用的
   1. 函数直接调用，this指向全局对象
   2. 通过一个对象的属性调用，格式为`对象.属性()`或`对象["属性"]`，`this`指向对象

```js
// 函数直接调用
func(); // 函数内的this指向全局对象window
// 通过对象调用
obj.func(); // 函数内的this指向对象
```

> 1. 谁调用函数，函数内的`this`就指向谁；直接调用就指向全局对象`window`

## 构造函数

用于创建对象的函数，可以减少繁琐的对象创建流程

>1. 构造函数返回一个对象
>2. 构造函数：构造函数专门用于创建对象

```js
new 函数名(参数);
```

如果使用上面的格式创建爱你对象，则该函数叫做**构造函数**

> 1. 我们在创建构造函数时，一般使用大驼峰命名
> 2. 构造函数内部会自动创建一个新对象，`this`指向新创建的对象，并自动返回新对象
> 3. 构造函数中如果出现返回值时，**如果返回的是原始类型，则等于没写**😅；**如果返回的是引用类型，则使用返回的结果**
> 4. 所有的对象，最终都是通过构造函数创造的（如：数组其实都是通过`new Array()`创建的）

### `new.target`

该表达式在**函数中使用**，返回的是当前的构造函数，但是，如果该函数不是通过`new`调用的，则返回`undfined`

通常用于判断某个函数是否通过`new`调用

```js
function User() {
	// this = {}; 可以这么理解，但实际不是这样的，并且this是不能赋值的
    if(new.target === User) {
	// 是通过new调用
    } else {
      // 不是通过new调用  
    }
}
```

## 函数的本质

函数的本质就是对象

> 所有的对象都是通过关键字`new`出来的，`new 构造函数()`
>
> 所有的函数，都是通过`new Function`创建的

由于函数本身就是对象，因此函数中，可以拥有各种属性

## 包装类

`JS`为了增强原始类型的功能，为`boolean、string、number`分别创建了一个构造函数

1. `Boolean`
2. `String`
3. `Number`

如果语法上，将原始类型当做对象使用时，（一般是在使用属性时），`JS`会自动在该位置利用对应的构造函数，创建对象来访问原始类型的属性。

> 类：在`JS`中，可以认为类就是构造函数
>
> 成员属性（方法）、实例属性（方法）：表示该属性是通过构造函数的对象调用的
>
> 静态属性（方法）、类属性（方法）：表示该属性是通过构造函数本身调用的
